<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        html, body
        {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
      </style>
</head>
<body>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        import Stats from "https://unpkg.com/three/examples/jsm/libs/stats.module.js";
        import {OrbitControls} from "https://unpkg.com/three@0.119.0/examples/jsm/controls/OrbitControls.js";
        import {OBJLoader} from 'https://cdn.jsdelivr.net/npm/three@0.117.1/examples/jsm/loaders/OBJLoader.js';

        "use strict";

        let renderer, scene, camera, orbitControls, stats, gui, dataReady = false, k = 0, data, trafficLightReady, scenary;
        let camera1, camera2, camera3, camera4;
        let semaforos = [];
        let lucesSemaforos = [];
        let ambientLight, directionalLight, skyBox, skyBoxNight, spotLight, pointLight, night = true;
        let redLightColor = 0xff0019, yellowLightColor = 0xfffb00, greenLightColor = 0x0a6104, offLightColor = 0x242020;
        window.multiview = false;
        
        function init(event) {
            // RENDERER ENGINE
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setClearColor(new THREE.Color(0, 0, 0));
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setScissorTest(true);
            document.body.appendChild(renderer.domElement);
            
            // SCENE
            scene = new THREE.Scene();

            // MODELS
            scenary = new Scenary();

            // SKYBOX
            skyBox = new SkyBox(25);
            skyBoxNight = new SkyBoxNight(25);

            // LIGHTS
            ambientLight = new AmbientLight();
            directionalLight = new DirectionalLight();

            // CAMERA
            camera1 = new Camera();
            camera1.setTrafficCamera(); //Traffic
            camera2 = new Camera();
            camera2.setTop(); //Top
            camera3 = new Camera();
            camera3.setFront(); // Front
            camera4 = new Camera();
            camera4.setPerspective(); // Perspective

            // SCENE GRAPH
            scene.add(scenary);
            scene.add(ambientLight);
            scene.add(directionalLight);
            scene.add(skyBox);
            scene.add(skyBoxNight);

            // SETUP STATS
            stats = new Stats();
            stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
            document.body.appendChild(stats.dom);

            // GUI
            gui = new dat.GUI();
            // SCENE-MENU
            const guiSceneMenu = gui.addFolder("Scene Menu");
            guiSceneMenu.add(scenary.axes, "visible").setValue(scenary.axes.visible).name("World Axes").listen().onChange(function(value) {
                scenary.axes.setVisible(value);
            });
            guiSceneMenu.add(window, "multiview").setValue(window.multiview).name("Multiview").listen().onChange(function(value) {   
            });
            guiSceneMenu.open();
            // CAMERA-MENU
            const guiCameraMenu = gui.addFolder("Camera Menu")
            guiCameraMenu.add(camera1.orbitControls, "autoRotate").setValue(false).name("Rotate Camera").listen().onChange(value => {
                camera1.setAutoRotate(value);
            });
            guiCameraMenu.add(camera1.viewTypes, "top").setValue(camera1.viewTypes["top"]).name("Top View").listen().onChange(value => {
                camera1.setTop();
            });
            guiCameraMenu.add(camera1.viewTypes, "front").setValue(camera1.viewTypes["front"]).name("Front View").listen().onChange(value => {
                camera1.setFront();
            });
            guiCameraMenu.add(camera1.viewTypes, "side").setValue(camera1.viewTypes["side"]).name("Side View").listen().onChange(value => {
                camera1.setSide();
            });
            //LIGHT-MENU
            const guiDirectionalLightMenu = gui.addFolder("Lights Menu");
            guiDirectionalLightMenu.add(directionalLight, "visible").name("Day").setValue(directionalLight.visible).listen().onChange(function(value) {
                night = !value;
                scenary.lights.forEach(light => {
                    light.visible = !light.visible
                    light.setIntensity(light.visible ? scenary.lightIntensity : 0)
                })
                ambientLight.visible = !ambientLight.visible
                    
            });
            guiDirectionalLightMenu.add(directionalLight, "intensity").name("Intensity").min(0).max(1).step(0.1).setValue(directionalLight.intensity)
            
            guiCameraMenu.add(camera1.viewTypes, "inModel").setValue(camera1.viewTypes["inModel"]).name("Model View").listen().onChange(value => {
                const carID = data.frames[0].cars[0].id;
                let car = scene.getObjectByName(carID);
                if(car){
                    camera1.setInModel(car);
                }
            });
            guiCameraMenu.add(camera1.viewTypes, "perspective").setValue(camera1.viewTypes["perspective"]).name("Perspective View").listen().onChange(value => {
                camera1.setPerspective();
            });
            guiCameraMenu.add(camera1.viewTypes, "traffic").setValue(camera1.viewTypes["traffic"]).name("Traffic Camera").listen().onChange(value => {
                camera1.setTrafficCamera();
            });

            // READ JSON FILE
            readTextFile("/testData.json", function(text) {
                data = JSON.parse(text);
                instantiateSportsCar();
                instantiateTrafficLights();
                dataReady = true;
                for(let i = 0; i < semaforos.length; i++) {
                    scene.add(semaforos[i]);
                    scene.add(lucesSemaforos[i]);
                }
            });

            function instantiateTrafficLights() {
                for (let trafLight of data.trafficLights){
                    let trafLightID = trafLight.id;
                    let trafLightX = trafLight.origin.x;
                    let trafLightZ = trafLight.origin.z;
                    let trafLightState = trafLight.state;
                    let trafLightDir = trafLight.dir;
                    let trafficLight = new Semaforo(trafLightX, trafLightZ, trafLightState, trafLightDir);
                    let pointLightSemaforo = new PointLight(trafLightX, 3, trafLightZ);
                    pointLightSemaforo.setIntensity(0.4)
                    trafficLight.name = trafLightID;
                    lucesSemaforos.push(pointLightSemaforo);
                    semaforos.push(trafficLight);
                }
            }

            function instantiateSportsCar() {
                for (let car of data.cars){
                    let carID = car.id;
                    let carX = car.origin.x;
                    let carZ = car.origin.z;
                    let sportsCar = new SportsCar(carX, carZ);
                    sportsCar.name = carID;
                    scene.add(sportsCar);
                }
            };

            // DRAW SCENE IN A RENDER LOOP (ANIMATION)
            renderLoop();
        }

        function renderLoop() {
            stats.begin();
            renderer.render(scene, camera1); // DRAW THE SCENE GRAPH
            updateScene();
            stats.end();
            requestAnimationFrame(renderLoop);
        }

        function updateScene() {
            if (night){
                skyBox.visible = false;
                skyBoxNight.visible = true;
            }else{
                skyBox.visible = true;
                skyBoxNight.visible = false;
            }
            if(camera1.orbitControls.autoRotate){
                camera1.orbitControls.update()
            }
           if (dataReady){
               k = (k + 1) % data.frames.length;
                for (let i = 0; i < data.frames[k].cars.length; i++){
                    const carID = data.frames[k].cars[i].id;
                    const x = data.frames[k].cars[i].x;
                    const z = data.frames[k].cars[i].z;
                    const dir = data.frames[k].cars[i].dir;
                    let car = scene.getObjectByName(carID);
                    if (car) {
                        car.setPosition(x, z);
                        car.setDirection(dir);
                        if(i == 0 && camera1.currentView == "inModel"){
                            camera1.setInModel(car);
                        }
                    } else {
                        console.log("Error")
                    } 
                }
                
                for (let j = 0; j < data.frames[k].trafficLights.length; j++){
                    const state = data.frames[k].trafficLights[j].state;
                    
                    if (trafficLightReady && state == 0) { //green
                        semaforos[j].green.material.color.setHex(greenLightColor);
                        semaforos[j].red.material.color.setHex(offLightColor);
                        semaforos[j].yellow.material.color.setHex(offLightColor);
                        lucesSemaforos[j].setColor(greenLightColor);
                    }else if (trafficLightReady && state == 1) { //yellow
                        semaforos[j].red.material.color.setHex(offLightColor);
                        semaforos[j].green.material.color.setHex(offLightColor);
                        semaforos[j].yellow.material.color.setHex(yellowLightColor);
                        lucesSemaforos[j].setColor(yellowLightColor)
                    }else if (trafficLightReady && state == 2) { //red
                        semaforos[j].red.material.color.setHex(redLightColor);
                        semaforos[j].green.material.color.setHex(offLightColor);
                        semaforos[j].yellow.material.color.setHex(offLightColor);
                        lucesSemaforos[j].setColor(redLightColor);
                    }
                }
                
           };
           if(!window.multiview) {
                camera1.aspect =  window.innerWidth / window.innerHeight;
                camera1.updateProjectionMatrix();
                renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
                renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
                renderer.render(scene, camera1);
            } else {
                 // CAMERA 1
                camera1.aspect = window.innerWidth/2. /  (window.innerHeight/2);
                camera1.updateProjectionMatrix();
                renderer.setViewport(0, window.innerHeight/2, window.innerWidth/2., window.innerHeight/2);
                renderer.setScissor(0, window.innerHeight/2, window.innerWidth/2., window.innerHeight/2);
                renderer.render(scene, camera1);

                // CAMERA 2
                camera2.aspect = window.innerWidth/2. / (window.innerHeight/2);
                camera2.updateProjectionMatrix();
                renderer.setViewport(window.innerWidth/2., window.innerHeight/2, window.innerWidth/2., window.innerHeight/2);
                renderer.setScissor(window.innerWidth/2., window.innerHeight/2, window.innerWidth/2., window.innerHeight/2);
                renderer.render(scene, camera2);

                // CAMERA 3
                camera3.aspect = window.innerWidth/2. / (window.innerHeight/2);
                camera3.updateProjectionMatrix();
                renderer.setViewport(0, 0, window.innerWidth/2., window.innerHeight/2);
                renderer.setScissor(0, 0, window.innerWidth/2., window.innerHeight/2);
                renderer.render(scene, camera3);

                // CAMERA 4
                camera4.aspect = window.innerWidth/2. / (window.innerHeight/2);
                camera4.updateProjectionMatrix();
                renderer.setViewport(window.innerWidth/2, 0, window.innerWidth/2., window.innerHeight/2);
                renderer.setScissor(window.innerWidth/2, 0, window.innerWidth/2., window.innerHeight/2);
                renderer.render(scene, camera4);
            }
        }

        function readTextFile(file, callback) {
            var rawFile = new XMLHttpRequest();
            rawFile.overrideMimeType("application/json");
            rawFile.open("GET", file, true);
            rawFile.onreadystatechange = function() {
                if (rawFile.readyState === 4 && rawFile.status == "200") {
                    callback(rawFile.responseText);
                }
            }
            rawFile.send(null);
        }

        // EVENT LISTENERS & HANDLERS
        document.addEventListener("DOMContentLoaded", init);

        window.addEventListener("resize", () => {
            if(!window.multiview) {
                camera1.aspect = window.innerWidth / window.innerHeight;
                camera1.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            } else {
                // CAMERA 1
                camera1.aspect = window.innerWidth / 2. / (window.innerHeight / 2);
                camera1.updateProjectionMatrix();
                // CAMERA 2
                camera2.aspect = window.innerWidth / 2. / (window.innerHeight / 2);
                camera2.updateProjectionMatrix();
                // CAMERA 3
                camera3.aspect = window.innerWidth / 2. / (window.innerHeight / 2);
                camera3.updateProjectionMatrix();
                // CAMERA 4
                camera4.aspect = window.innerWidth / 2. / (window.innerHeight / 2);
                camera4.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }            
        }, false);

        class Axes extends THREE.AxesHelper {
            constructor(size = 10, visible = false) {
                super(size);
                this.size = size;
                this.visible = visible;
                this.position.set(0, 1, 0);
            }
            setVisible(value) {
                this.visible = value;
            }
        }

        class Floor extends THREE.Group {
            constructor(size = 30) {
                super();
                this.size = size;
                const geometry = new THREE.PlaneGeometry(size, size);
                const material = new THREE.MeshPhongMaterial({color: 0x363636});
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.x = -Math.PI / 2;
                this.gridHelper = new THREE.GridHelper(size, 10, 0xff0000, 0x000000);
                // CHILDREN
                this.add(this.mesh);
                this.add(this.gridHelper);
            }
            setVisible(value = true) {
                this.visible = value;
            }
            setWireframe(value = true) {
                this.material.wireframe = value;
            }
            setColor(color) {
                this.mesh.material.color.setHex(color);
            }
        }

        class SportsCar extends THREE.Group {
            constructor(x = 0, z = 0, objFileName = "./assets/Car.obj") {
                super();
                this.x = x;
                this.z = z;
                this.position.set(x, 0, z);
                this.color = 0xcc0000;
                this.wireColor = 0xffffff;
                this.doubleSide = false;
                this.rotate = false;
                this.objFileName = objFileName;
                this.loadOBJModel(objFileName);
                this.theta = 0;
                this.rotation.y = 0;
            }
            setPosition(x, z) {
                this.x = x;
                this.z = z;
                this.position.set(x, 0, z);
            }
            setDirection(dir) {
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
            loadOBJModel(objFileName) {
                // instantiate a loader
                const loader = new OBJLoader();
                // load a resource
                const model = this;
                loader.load(objFileName,
                    // called when resource is loaded
                    function (object) { 
                        // SOLID
                        object.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({color: model.color});
                            }
                        });
                        model.solid = object;
                        // WIRE
                        model.wire = object.clone();
                        model.wire.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({wireframe: true, color: model.wireColor});
                            }
                        });
                        model.scale.set(1, 1, 1);
                        // CHILDREN
                        model.add(model.solid);
                        model.add(model.wire);
                        scene.add(model);
                        model.setOnFloor();
                                
                        // // MODEL-MENU
                        const guiModelMenu = gui.addFolder("Model Menu");
                        // // GUI-Model
                        guiModelMenu.add(model, "visible").setValue(model.visible).name("Visible").listen().onChange(function(value) {
                            for (let car of data.cars){
                                let carID = car.id;
                                let thisCar = scene.getObjectByName(carID);
                                if(car){
                                    thisCar.setVisible(value);
                                } 
                            } 
                        });
                        guiModelMenu.add(model.solid, "visible").setValue(model.solid.visible).name("Wireframe").listen().onChange(function(value) {
                            for (let car of data.cars){
                                let carID = car.id;
                                let thisCar = scene.getObjectByName(carID);
                                if(car){
                                    thisCar.setWireframe(value);
                                } 
                            }   
                        });
                        guiModelMenu.add(model, "doubleSide").setValue(model.doubleSide).name("Double Side").listen().onChange(function(value) {
                            for (let car of data.cars){
                                let carID = car.id;
                                let thisCar = scene.getObjectByName(carID);
                                if(car){
                                    thisCar.setDoubleSide(value);
                                } 
                            }     
                        });
                        guiModelMenu.addColor(model, "color").name("Color").setValue(model.color).listen().onChange(function(value) {
                            for (let car of data.cars){
                                let carID = car.id;
                                let thisCar = scene.getObjectByName(carID);
                                if(car){
                                    thisCar.setColor(value);
                                } 
                            } 
                        });
                        guiModelMenu.addColor(model, "wireColor").name("Wire Color").setValue(model.wireColor).listen().onChange(function(value) {
                            for (let car of data.cars){
                                let carID = car.id;
                                let thisCar = scene.getObjectByName(carID);
                                if(car){
                                    thisCar.setWireColor(value);
                                } 
                            }
                        });
                    },
                    // called when loading is in progresses
                    function (xhr) {
                            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                    // called when loading has errors
                    function (error) {
                        console.log( 'An error happened' + error );
                    }
                );
            }
            setVisible(value){
                this.visible = value;
            }
            setWireframe(value){
                this.solid.visible = value;
            }
            setColor(hexColor) {
                this.color = hexColor;
                this.solid.traverse(function(child) {
                                if (child.isMesh) {
                                    child.material.color.setHex(hexColor);
                                }
                });
            }
            setWireColor(hexColor) {
                this.wireColor = hexColor;
                this.wire.traverse(function(child) {
                                if (child.isMesh) {
                                    child.material.color.setHex(hexColor);
                                }
                });
            }
            setDoubleSide(value) {
                this.doubleSide = value;
                this.solid.traverse(function(child) {
                    if (child.isMesh) {
                        if(value) {
                            child.material.side = THREE.DoubleSide;
                        } else {
                            child.material.side = THREE.FrontSide;
                        }
                    }
                });
            }
            setOnFloor() {
                const bBox = new THREE.Box3();
                bBox.setFromObject(this.solid);
                this.position.y = -bBox.min.y;
            }
        }

        class Building extends THREE.Group {
            constructor(x = 0, z = 0, dir = 0, objFileName = "./assets/lowPolyBuilding.obj", y = 4) {
                super();
                this.x = x;
                this.z = z;
                this.position.set(x, y, z);
                this.color = 0x996677;
                this.wireColor = 0xffffff;
                this.doubleSide = false;
                this.rotate = false;
                this.objFileName = objFileName;
                this.loadOBJModel(objFileName);
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
            setWireframe(value = true) {
                this.solid.setVisible(value);
            }
            setColor(hexColor) {
                this.color = hexColor;
                this.solid.material.color.setHex(hexColor);
            }
            setWireColor(hexColor) {
                this.wireColor = hexColor;
                this.wire.material.color.setHex(hexColor);
            }
            loadOBJModel(objFileName) {
                // instantiate a loader
                const loader = new OBJLoader();
                // load a resource
                const model = this;
                loader.load(objFileName,
                    // called when resource is loaded
                    function (object) { 
                        // SOLID
                        object.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({color: model.color, side: THREE.FrontSide});
                            }
                        });
                        model.solid = object;
                        // WIRE
                        model.wire = object.clone();
                        model.wire.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({wireframe: true, color: model.wireColor, side: THREE.FrontSide});
                            }
                        });
                        //model.rotation.y = Math.PI;
                        model.scale.set(20, 20, 20);
                        // CHILDREN
                        model.add(model.solid);
                        model.add(model.wire);

                        scene.add(model);
                    },
                        // called when loading is in progresses
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                        // called when loading has errors
                    function (error) {
                        console.log( 'An error happened' + error );
                    }
                );
            }
            setDoubleSide(value) {
                this.doubleSide = value;
                if(value) {
                    this.solid.material.side = THREE.DoubleSide;
                } else {
                    this.solid.material.side = THREE.FrontSide;
                }
            }
            setDirection(dir) {
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
        }

        class BuildingLod extends THREE.LOD {
            constructor(x, z, dir, y) {
                super();
                this.x = x;
                this.z = z;
                this.dir = dir;
                this.position.set(x, y, z);
                this.color = 0x996677;
                this.wireColor = 0xffffff;
                this.doubleSide = false;
                this.rotate = false;
                // Geometry
                const geometryLow = new THREE.BoxGeometry(20, 25, 20);
                const geometryHigh = new Building(this.x, this.z, this.dir);
                const material = new THREE.MeshPhongMaterial({color: this.color});
                const materialWire = new THREE.MeshPhongMaterial({wireframe: true, color: this.wireColor});
                // LOW
                this.low = new THREE.Group();
                this.low.solid = new THREE.Mesh(geometryLow, material);
                this.low.wire = new THREE.Mesh(geometryLow, materialWire);
                //CHILDREN
                this.low.add(this.low.solid);
                this.low.add(this.low.wire);
                // HIGH
                this.high = geometryHigh;

                // CHILDREN
                this.addLevel(this.low, 250);
                this.addLevel(this.high, 1);

                this.setOnFloor();
            }
            setOnFloor() {
                this.low.solid.geometry.computeBoundingBox();
                const bBox = this.low.solid.geometry.boundingBox;
                this.position.y = -bBox.min.y;
            }
        }

        class Semaforo extends THREE.Group {
            constructor(x = 0, z = 0, state = 0, dir = 0, objFileName = "./assets/objetos/traffic-light-original/traffic-light.obj") {
                super();
                this.x = x;
                this.z = z;
                this.green;
                this.red;
                this.yellow;
                this.state = state;
                this.position.set(x, 0, z);
                this.color = 0x242020;
                this.wireColor = 0xffffff;
                this.doubleSide = false;
                this.rotate = false;
                this.objFileName = objFileName;
                this.loadOBJModel(objFileName);
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
            setDirection(dir) {
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
            setColor(hexColor) {
                this.color = hexColor;
                this.solid.material.color.setHex(hexColor);
            }
            loadOBJModel(objFileName) {
                // instantiate a loader
                const loader = new OBJLoader();
                // load a resource
                const model = this;
                loader.load(objFileName,
                    // called when resource is loaded
                    function (object) { 
                        // SOLID
                        object.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({color: model.color});
                                // Abajo
                                if (child.name == "group1 pSphere1"){
                                    model.green = child;
                                }
                                // Medio
                                if (child.name == "group1 pSphere2"){
                                    model.yellow = child;
                                }
                                // Arriba
                                if (child.name == "group1 pSphere3"){
                                    model.red = child
                                }
                            }
                        });
                        model.solid = object;
                        // WIRE
                        model.wire = object.clone();
                        model.wire.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({wireframe: true, color: model.wireColor});
                            }
                        });
                        model.scale.set(0.5, 0.5, 0.5);
                        // CHILDREN
                        model.add(model.solid);
                        trafficLightReady = true;
                        scene.add(model);
                    },
                        // called when loading is in progresses
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                        // called when loading has errors
                    function (error) {
                        console.log( 'An error happened' + error );
                    }
                );
            }
            setDoubleSide(value) {
                this.doubleSide = value;
                if(value) {
                    this.solid.material.side = THREE.DoubleSide;
                } else {
                    this.solid.material.side = THREE.FrontSide;
                }
            }
        }

        class Scenary extends THREE.Group {
            constructor(size = 1000) {
                super();
                this.axes = new Axes(size);
                this.floor = new Floor(size);
                this.buildings = [];
                this.lights = [];
                this.showWireframe = false
                this.lightIntensity = 0.3

                //SE
                this.buildings.push(new BuildingLod(282.5, 35, 180));
                //
                this.buildings.push(new BuildingLod(255, 35, 180));
                this.buildings.push(new BuildingLod(305, 35, 180));

                // SW (Tec)
                this.buildings.push(new BuildingLod(-90, 35, 180));
                this.buildings.push(new BuildingLod(-150, 35, 180));
                this.buildings.push(new BuildingLod(-210, 35, 180));
                this.buildings.push(new BuildingLod(-270, 35, 180));
                this.buildings.push(new BuildingLod(-330, 35, 180));
                //
                this.buildings.push(new GasStation(-50, 45, 270, 0xff6700));
                this.buildings.push(new BuildingLod(-120, 35, 180));
                this.buildings.push(new BuildingLod(-180, 35, 180));
                this.buildings.push(new BuildingLod(-240, 35, 180));
                this.buildings.push(new BuildingLod(-300, 35, 180));
                
                // NE
                this.buildings.push(new BuildingLod(70, -35))
                this.buildings.push(new BuildingLod(130, -35))
                this.buildings.push(new BuildingLod(190, -35))
                this.buildings.push(new BuildingLod(250, -35))
                this.buildings.push(new BuildingLod(310, -35))
                //
                this.buildings.push(new GasStation(35, -45, 180));
                this.buildings.push(new BuildingLod(100, -35));
                this.buildings.push(new BuildingLod(160, -35));
                this.buildings.push(new BuildingLod(220, -35));
                this.buildings.push(new BuildingLod(280, -35));
                
                // NW
                this.buildings.push(new BuildingLod(-65, -35))
                this.buildings.push(new BuildingLod(-125, -35))
                this.buildings.push(new BuildingLod(-185, -35))
                this.buildings.push(new BuildingLod(-245, -35))
                this.buildings.push(new BuildingLod(-310, -35))
                //
                this.buildings.push(new BuildingLod(-35, -35));
                this.buildings.push(new BuildingLod(-95, -35));
                this.buildings.push(new BuildingLod(-155, -35));
                this.buildings.push(new BuildingLod(-215, -35));
                this.buildings.push(new BuildingLod(-275, -35));

                //los de la calle nueva cera de enfrente lado izq
                this.buildings.push(new BuildingLod(35, -90, 270));
                this.buildings.push(new BuildingLod(35, -120, 270));
                this.buildings.push(new BuildingLod(35, -150, 270));
                this.buildings.push(new BuildingLod(35, -180, 270));

                //los de la calle nueva cera de atr치s lado izq
                this.buildings.push(new BuildingLod(-35, -70, 90));
                this.buildings.push(new BuildingLod(-35, -100, 90));
                this.buildings.push(new BuildingLod(-35, -130, 90));
                this.buildings.push(new BuildingLod(-35, -160, 90));

                //los de la calle nueva cera de atr치s lado derecho
                this.buildings.push(new BuildingLod(-35, 85, 90));
                this.buildings.push(new BuildingLod(-35, 115, 90));
                this.buildings.push(new BuildingLod(-35, 145, 90));
                this.buildings.push(new BuildingLod(-35, 175, 90));
                
                //---Pante칩n---
                this.buildings.push(new Gate(25, 120, 270)); //Gate Obj
                let wall = new THREE.BoxGeometry(2, 14.5, 105);
                let wallMaterial = new THREE.MeshPhongMaterial({color: 0xE56717, side: THREE.DoubleSide});
                
                //Paredes frontales
                let paredFrontal = new THREE.Mesh(wall, wallMaterial);
                paredFrontal.position.set(26, 0.5, 72.5); //mitad + 20
                this.buildings.push(paredFrontal);
                let paredFrontalDer = new THREE.Mesh(wall, wallMaterial);
                paredFrontalDer.position.set(26, 0.5, 192.5);
                this.buildings.push(paredFrontalDer);
                
                //Pared trasera
                let backWall = new THREE.BoxGeometry(2, 14.5, 224);
                let paredTrasera = new THREE.Mesh(backWall, wallMaterial);
                paredTrasera.position.set(231, 0.5, 132);
                this.buildings.push(paredTrasera);
                
                //Paredes laterales
                let latWall = new THREE.BoxGeometry(205, 14.5, 2);
                let paredLateralIzq = new THREE.Mesh(latWall, wallMaterial);
                paredLateralIzq.position.set(129, 0.5, 21);
                this.buildings.push(paredLateralIzq);
                let paredLateralDer = new THREE.Mesh(latWall, wallMaterial);
                paredLateralDer.position.set(129, 0.5, 244);
                this.buildings.push(paredLateralDer);
                
                //Pasto
                let ground = new THREE.BoxGeometry(205, 1.5, 222);
                const grassTexture = new THREE.TextureLoader().load("./assets/grass.jpg");
                grassTexture.wrapS = THREE.RepeatWrapping;
                grassTexture.wrapT = THREE.RepeatWrapping;
                grassTexture.repeat.set(20, 20);
                let grass = new THREE.MeshPhongMaterial({map: grassTexture, side: THREE.DoubleSide});
                let restingGround = new THREE.Mesh(ground, grass);
                restingGround.position.set(128, 0, 132);
                this.buildings.push(restingGround);
                
                //Tumbas
                for(var i = 45; i <= 195; i += 25){
                    for(let j = 40; j <= 235; j += 20){
                        this.buildings.push(new Grave(i, j, 270));
                    }
                }

                //Berd
                this.buildings.push(new Berd(700, 0, 270));
                this.buildings.push(new Berd(-700, 0, 90));
                this.buildings.push(new Berd(0, 700, 180));
                this.buildings.push(new Berd(0, -700, 0));

                //Tec
                let tecGeometry = new THREE.BoxGeometry(250, 25, 280);
                let materialTec = new THREE.MeshPhongMaterial({color: 0x0000ff, side: THREE.DoubleSide});
                let tec = new THREE.Mesh(tecGeometry, materialTec);
                tec.position.set(150, 10, -338)
                this.buildings.push(tec);

                //Banquetas
                let geometry = new THREE.BoxGeometry(475, 1, 475);
                const texture = new THREE.TextureLoader().load("./assets/street.jpg");
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
                let material = new THREE.MeshPhongMaterial({map: texture, side: THREE.DoubleSide});
                let rightUpperStreet = new THREE.Mesh( geometry, material );
                rightUpperStreet.position.set(250, 0, 250)
                this.buildings.push(rightUpperStreet);
                let leftUpperStreet = new THREE.Mesh( geometry, material );
                leftUpperStreet.position.set(250, 0, -250)
                this.buildings.push(leftUpperStreet);
                let rightLowerStreet = new THREE.Mesh( geometry, material );
                rightLowerStreet.position.set(-250, 0, 250)
                this.buildings.push(rightLowerStreet);
                let leftLowerStreet = new THREE.Mesh( geometry, material );
                leftLowerStreet.position.set(-250, 0, -250)
                this.buildings.push(leftLowerStreet);

                // Camellon
                let geometryCamellon = new THREE.BoxGeometry(470, 0.5, 2);
                // Aviacion Sur
                let aviacionSurCamellon= new THREE.Mesh( geometryCamellon, material );
                aviacionSurCamellon.position.set(250, 0, 0)
                this.buildings.push(aviacionSurCamellon);
                // Aviacion Norte
                let aviacionNorteCamellon= new THREE.Mesh( geometryCamellon, material );
                aviacionNorteCamellon.position.set(-250, 0, 0)
                this.buildings.push(aviacionNorteCamellon);
                // Ramon Este
                let aviacionEsteCamellon= new THREE.Mesh( geometryCamellon, material );
                aviacionEsteCamellon.position.set(0, 0, -250)
                aviacionEsteCamellon.rotation.y = 90 * Math.PI / 180;
                this.buildings.push(aviacionEsteCamellon);
                // Ramon Oeste
                let aviacionOesteCamellon = new THREE.Mesh( geometryCamellon, material );
                aviacionOesteCamellon.position.set(0, 0, 250)
                aviacionOesteCamellon.rotation.y = 90 * Math.PI / 180;
                this.buildings.push(aviacionOesteCamellon);

                // Lineas peatonales
                let geometryPeatonal = new THREE.BoxGeometry(7, 0.1, 2);
                let materialPeaton = new THREE.MeshPhongMaterial({color: 0xe9c96b, side: THREE.DoubleSide});
                // Aviacion Sur
                for (let i = -14; i<=14; i += 3) {
                    let aviacionSurPeatonal = new THREE.Mesh( geometryPeatonal, materialPeaton );
                    aviacionSurPeatonal.position.set(19, 0, i+0.5);
                    this.buildings.push(aviacionSurPeatonal);
                }
                // Aviacion Norte
                for (let i = -14; i<=14; i += 3) {
                    let aviacionNortePeatonal = new THREE.Mesh( geometryPeatonal, materialPeaton );
                    aviacionNortePeatonal.position.set(-19, 0, i+0.5);
                    this.buildings.push(aviacionNortePeatonal);
                }
                // Ramon Este
                for (let i = -14; i<=14; i += 3) {
                    let ramonEstePeatonal = new THREE.Mesh( geometryPeatonal, materialPeaton );
                    ramonEstePeatonal.position.set(i+0.5, 0, 19);
                    ramonEstePeatonal.rotation.y = 90 * Math.PI / 180;
                    this.buildings.push(ramonEstePeatonal);
                }
                // Ramon Oeste
                for (let i = -14; i<=14; i += 3) {
                    let ramonOestePeatonal = new THREE.Mesh( geometryPeatonal, materialPeaton );
                    ramonOestePeatonal.position.set(i+0.5, 0, -19);
                    ramonOestePeatonal.rotation.y = 90 * Math.PI / 180;
                    this.buildings.push(ramonOestePeatonal);
                }

                // CHILDREN
                this.add(this.axes);
                this.add(this.floor);

                // Aviacion
                const lightIntensity = this.lightIntensity
                this.buildings.push(new Lamp(30, 4.5, 0));
                this.lights.push(new SpotLight(30, 10, 4.5, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(90, -4.5, 180));
                this.lights.push(new SpotLight(90, 10, -4.5, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(150, 4.5, 0));
                this.lights.push(new SpotLight(150, 10, 4.5, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(210, -4.5, 180));
                this.lights.push(new SpotLight(210, 10, -4.5, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(-30, 4.5, 0));
                this.lights.push(new SpotLight(-30, 10, 4.5, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(-90, -4.5, 180));
                this.lights.push(new SpotLight(-90, 10, -4.5, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(-150, 4.5, 0));
                this.lights.push(new SpotLight(-150, 10, 4.5, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(-210, -4.5, 180));
                this.lights.push(new SpotLight(-210, 10, -4.5, 0xf8d879, lightIntensity, 0, 60, 1));

                // Ramon Corona
                this.buildings.push(new Lamp(4.5, 30, 90));
                this.lights.push(new SpotLight(4.5, 10, 30, 0xf8d879, lightIntensity, 0, 60, 1));
                
                this.buildings.push(new Lamp(-4.5, 90, 270));
                this.lights.push(new SpotLight(-4.5, 10, 90, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(4.5, 150, 90));
                this.lights.push(new SpotLight(4.5, 10, 150, 0xf8d879, lightIntensity, 0, 60, 1));
                
                this.buildings.push(new Lamp(-4.5, 210, 270));
                this.lights.push(new SpotLight(-4.5, 10, 210, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(4.5, -30, 90));
                this.lights.push(new SpotLight(4.5, 10, -30, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(-4.5, -90, 270));
                this.lights.push(new SpotLight(-4.5, 10, -90, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(4.5, -150, 90));
                this.lights.push(new SpotLight(4.5, 10, -150, 0xf8d879, lightIntensity, 0, 60, 1));

                this.buildings.push(new Lamp(-4.5, -210, 270));
                this.lights.push(new SpotLight(-4.5, 10, -210, 0xf8d879, lightIntensity, 0, 60, 1));


                for(let i = 0; i < this.buildings.length; i++) {
                    this.add(this.buildings[i]);
                }

                for(let i = 0; i < this.lights.length; i++) {
                    this.add(this.lights[i]);
                }
            }
        }

        // CAMERA (PERSPECTIVE)
        class Camera extends THREE.PerspectiveCamera {
            constructor(fov = 60, aspect = window.innerWidth / window.innerHeight, near = 0.01, far = 10000.0) {
                super(fov, aspect, near, far)
                // CAMERA CONTROLS
                this.orbitControls = new OrbitControls(this, renderer.domElement);
                this.orbitControls.update(); // Es necesario siempre que se actualiza la c치mara

                // Views
                this.viewTypes = {
                    "top": false,
                    "perspective": false,
                    "front": false,
                    "side": false,
                    "inModel": false,
                    "closeToModel": false,
                    "focusOnModel": false,
                    "traffic": false
                }
                this.currentView = ""

            }

            setPerspective() {
                this.viewTypes[this.currentView] = false;
                this.currentView = "perspective";
                this.viewTypes[this.currentView] = true;
                this.position.set(-100, 100, 300);
                this.orbitControls.target = new THREE.Vector3(0, 0, 0);
                this.up.set(0, 1, 0)
                this.orbitControls.update();
            }

            setTop() {
                this.viewTypes[this.currentView] = false;
                this.currentView = "top"
                this.viewTypes[this.currentView] = true;
                this.position.set(0, 250, 0);
                this.orbitControls.target = new THREE.Vector3(0, 0, 0);
                this.up.set(1, 0, 0)
                this.orbitControls.update();
            }

            setFront() {
                this.viewTypes[this.currentView] = false;
                this.currentView = "front";
                this.viewTypes[this.currentView] = true;
                this.position.set(0, 60, 300);
                this.orbitControls.target = new THREE.Vector3(0, 0, 0);
                this.up.set(0, 1, 0);
                this.orbitControls.update();
            }

            setSide() {
                this.viewTypes[this.currentView] = false;
                this.currentView = "side";
                this.viewTypes[this.currentView] = true;
                this.position.set(300, 60, 0);
                this.orbitControls.target = new THREE.Vector3(0, 0, 0);
                this.up.set(0, 1, 0);
                this.orbitControls.update();
            }

            setInModel(model) {
                if(this.currentView != "inModel") {
                    this.viewTypes[this.currentView] = false;
                    this.currentView = "inModel";
                    this.viewTypes[this.currentView] = true;
                    this.up.set(0, 1, 0);
                }
                this.position.set(model.position.x, model.position.y + 1.4, model.position.z - 0.35);
                this.orbitControls.target = new THREE.Vector3(model.position.x + 7, model.position.y + 1.4, model.position.z);
                this.orbitControls.update();
            }

            setTrafficCamera() {
                this.viewTypes[this.currentView] = false;
                this.currentView = "traffic";
                this.viewTypes[this.currentView] = true;
                this.position.set(-20, 14, -20);
                this.orbitControls.target = new THREE.Vector3(5, 6, 0);
                this.up.set(0, 1, 0);
                this.orbitControls.update();
            }

            setAutoRotate(value = true) {
                this.orbitControls.autoRotate = value
            }
        }

        class AmbientLight extends THREE.AmbientLight {
            constructor(color = 0xFFFFFF, intensity = 0.4) {
                super(color, intensity);
                this.visible = false;
                this.strColor = color;
            }
            setColor(strColor) {
                this.color.setHex(strColor);
            }
        }

        class DirectionalLight extends THREE.DirectionalLight {
            constructor(color = 0xFFFFFF, intensity = 0.4) {
                super(color, intensity);
                this.visible = false;
                this.strColor = color;
                this.position.set(0, 99, 0);
            }
            setColor(strColor) {
                this.color.setHex(strColor);
            }
        }

        class SkyBox extends THREE.Mesh {
            constructor(size = 1) {
                super();
                this.size = size;
                this.doubleSide = false;
                this.rotate = false;
                this.geometry = new THREE.BoxGeometry(size, size, size);
                this.material = [
                         new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/sh_ft.png"), side: THREE.DoubleSide}),
                         new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/sh_bk.png"), side: THREE.DoubleSide}),
                         new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/sh_up.png"), side: THREE.DoubleSide}),
                         new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/sh_dn.png"), side: THREE.DoubleSide}),
                         new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/sh_rt.png"), side: THREE.DoubleSide}),
                         new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/sh_lf.png"), side: THREE.DoubleSide})
                        ];
                this.scale.set(50, 50, 50);
            }
            setDoubleSide(value) {
                this.doubleSide = value;
                if(value) {
                    this.material.side = THREE.DoubleSide;
                } else {
                    this.material.side = THREE.FrontSide;
                }
            }
        }

        class SkyBoxNight extends THREE.Mesh {
            constructor(size = 1) {
                super();
                this.size = size;
                this.doubleSide = false;
                this.rotate = false;
                this.geometry = new THREE.BoxGeometry(size, size, size);
                this.material = [
                    new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/SkyNight_Front.png"), side: THREE.DoubleSide}),
                    new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/SkyNight_Back.png"), side: THREE.DoubleSide}),
                    new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/SkyNight_Top.png"), side: THREE.DoubleSide}),
                    new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/SkyNight_Bottom.png"), side: THREE.DoubleSide}),
                    new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/SkyNight_Right.png"), side: THREE.DoubleSide}),
                    new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("./assets/texture/SkyNight_Left.png"), side: THREE.DoubleSide})
                ];
                this.scale.set(50, 50, 50);
            }
            setDoubleSide(value) {
                this.doubleSide = value;
                if(value) {
                    this.material.side = THREE.DoubleSide;
                } else {
                    this.material.side = THREE.FrontSide;
                }
            }
        }

        //Testing adding gas stations
        class GasStation extends THREE.Group {
            constructor(x = 0, z = 0, dir = 0, color = 0x119977, objFileName = "./assets/newGasStation.obj", y = -46) {
                super();
                this.x = x;
                this.z = z;
                this.position.set(x, y, z);
                this.color = color;
                this.wireColor = 0xffffff;
                this.doubleSide = false;
                this.rotate = false;
                this.objFileName = objFileName;
                this.loadOBJModel(objFileName);
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
            loadOBJModel(objFileName) {
                // instantiate a loader
                const loader = new OBJLoader();
                // load a resource
                const model = this;
                loader.load(objFileName,
                    // called when resource is loaded
                    function (object) { 
                        // SOLID
                        object.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({color: model.color, side: THREE.FrontSide});
                            }
                        });
                        model.solid = object;
                        // WIRE
                        model.wire = object.clone();
                        model.wire.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({wireframe: true, color: model.wireColor, side: THREE.FrontSide});
                            }
                        });
                        //model.rotation.y = Math.PI;
                        model.scale.set(22, 22, 22);
                        // CHILDREN
                        model.add(model.solid);
                        model.add(model.wire);
                        scene.add(model);
                    },
                        // called when loading is in progresses
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                        // called when loading has errors
                    function (error) {
                        console.log( 'An error happened' + error );
                    }
                );
            }
            setDirection(dir) {
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
        }

        //Testing adding lamps
        class Lamp extends THREE.Group {
            constructor(x = 0, z = 0, dir = 0, objFileName = "./assets/lamp.obj", y = -17) {
                super();
                this.x = x;
                this.z = z;
                this.position.set(x, y, z);
                this.color = 0xacabab;
                this.wireColor = 0xffffff;
                this.doubleSide = false;
                this.rotate = false;
                this.objFileName = objFileName;
                this.loadOBJModel(objFileName);
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
            loadOBJModel(objFileName) {
                // instantiate a loader
                const loader = new OBJLoader();
                // load a resource
                const model = this;
                loader.load(objFileName,
                    // called when resource is loaded
                    function (object) { 
                        // SOLID
                        object.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({color: model.color, side: THREE.FrontSide});
                            }
                        });
                        model.solid = object;
                        // WIRE
                        model.wire = object.clone();
                        model.wire.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({wireframe: true, color: model.wireColor, side: THREE.FrontSide});
                            }
                        });
                        //model.rotation.y = Math.PI;
                        model.scale.set(8, 8, 8);
                        // CHILDREN
                        model.add(model.solid);
                        model.add(model.wire);
                        scene.add(model);
                    },
                        // called when loading is in progresses
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                        // called when loading has errors
                    function (error) {
                        console.log( 'An error happened' + error );
                    }
                );
            }
            setDirection(dir) {
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
        }

        class SpotLight extends THREE.SpotLight {
            constructor(x = 0, y = 0, z = 0, color = 0xFFFFFF, intensity = 1, distance = 0, angle = Math.PI / 2, penumbra = 0,  decay = 1) {
                super(color, intensity, distance, angle, penumbra, decay);
                this.angleDeg = angle * 180 / Math.PI;
                this.strColor = color;
                this.position.set(x, y, z); //(48, 12 15)
            }
            setColor(strColor) {
                this.color.setHex(strColor);
            }
            setAngle(angleDeg) {
                this.angle = angleDeg * Math.PI / 180;
            }
            setIntensity(value) {
                this.intensity = value;
            }
        }

        class PointLight extends THREE.PointLight {
            constructor(x = 0, y = 3, z = 0, color = 0xFFFFFF, intensity = 0.5) {
                super(color, intensity);
                this.intensity = intensity
                this.strColor = color;
                this.position.set(x, y, z);
            }
            setColor(strColor) {
                this.color.setHex(strColor);
            }
            setIntensity(value) {
                this.intensity = value;
            }
        }

        class Gate extends THREE.Group {
            constructor(x = 0, z = 0, dir = 0, objFileName = "./assets/gate.obj", y = -32) {
                super();
                this.x = x;
                this.z = z;
                this.position.set(x, y, z);
                this.color = 0xE56717;
                this.wireColor = 0xffffff;
                this.doubleSide = false;
                this.rotate = false;
                this.objFileName = objFileName;
                this.loadOBJModel(objFileName);
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
            loadOBJModel(objFileName) {
                // instantiate a loader
                const loader = new OBJLoader();
                // load a resource
                const model = this;
                loader.load(objFileName,
                    // called when resource is loaded
                    function (object) { 
                        // SOLID
                        object.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({color: model.color, side: THREE.FrontSide});
                            }
                        });
                        model.solid = object;
                        // WIRE
                        model.wire = object.clone();
                        model.wire.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({wireframe: true, color: model.wireColor, side: THREE.FrontSide});
                            }
                        });
                        //model.rotation.y = Math.PI;
                        model.scale.set(10, 10, 10);
                        // CHILDREN
                        model.add(model.solid);
                        model.add(model.wire);
                        scene.add(model);
                    },
                        // called when loading is in progresses
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                        // called when loading has errors
                    function (error) {
                        console.log( 'An error happened' + error );
                    }
                );
            }
            setDirection(dir) {
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
        }

        class Grave extends THREE.Group {
            constructor(x = 0, z = 0, dir = 0, objFileName = "./assets/grave.obj", y = -4.8) {
                super();
                this.x = x;
                this.z = z;
                this.position.set(x, y, z);
                this.color = 0x444444;
                this.wireColor = 0xffffff;
                this.doubleSide = false;
                this.rotate = false;
                this.objFileName = objFileName;
                this.loadOBJModel(objFileName);
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
            loadOBJModel(objFileName) {
                // instantiate a loader
                const loader = new OBJLoader();
                // load a resource
                const model = this;
                loader.load(objFileName,
                    // called when resource is loaded
                    function (object) { 
                        // SOLID
                        object.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({color: model.color, side: THREE.FrontSide});
                            }
                        });
                        model.solid = object;
                        // WIRE
                        model.wire = object.clone();
                        model.wire.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({wireframe: true, color: model.wireColor, side: THREE.FrontSide});
                            }
                        });
                        //model.rotation.y = Math.PI;
                        model.scale.set(2, 2, 2);
                        // CHILDREN
                        model.add(model.solid);
                        model.add(model.wire);
                        scene.add(model);
                    },
                        // called when loading is in progresses
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                        // called when loading has errors
                    function (error) {
                        console.log( 'An error happened' + error );
                    }
                );
            }
            setDirection(dir) {
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
        }

        class Berd extends THREE.Group {
            constructor(x = 0, z = 0, dir = 0, objFileName = "./assets/berd.obj", y = -4.8) {
                super();
                this.x = x;
                this.z = z;
                this.position.set(x, y, z);
                this.color = 0xff0000;
                this.wireColor = 0xffffff;
                this.doubleSide = false;
                this.rotate = false;
                this.objFileName = objFileName;
                this.loadOBJModel(objFileName);
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
            loadOBJModel(objFileName) {
                // instantiate a loader
                const loader = new OBJLoader();
                // load a resource
                const model = this;
                loader.load(objFileName,
                    // called when resource is loaded
                    function (object) { 
                        // SOLID
                        object.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({color: model.color, side: THREE.FrontSide});
                            }
                        });
                        model.solid = object;
                        // WIRE
                        model.wire = object.clone();
                        model.wire.traverse(function(child) {
                            if (child.isMesh) {
                                child.material = new THREE.MeshPhongMaterial({wireframe: true, color: model.wireColor, side: THREE.FrontSide});
                            }
                        });
                        model.scale.set(100, 100, 100);
                        // CHILDREN
                        model.add(model.solid);
                        //model.add(model.wire);
                        scene.add(model);
                    },
                        // called when loading is in progresses
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                        // called when loading has errors
                    function (error) {
                        console.log( 'An error happened' + error );
                    }
                );
            }
            setDirection(dir) {
                this.theta = dir;
                this.rotation.y = dir * Math.PI / 180;
            }
            setPosition(x, z, y) {
                this.x = x;
                this.z = z;
                this.position.set(x, y, z);
            }
        }

    </script>
</body>
</html>